
import tkinter as tk from tkinter import messagebox from tkinter import ttk import math import ast import re import random import ttkbootstrap as tb from ttkbootstrap.constants import *

------------------------------ Safe Evaluator ------------------------------

class SafeEvaluator(ast.NodeVisitor): """Safely evaluates math expressions using Python's AST with a strict whitelist. Supports functions/constants defined in env. Percent and factorial are preprocessed before evaluation. """

def __init__(self, env: dict): self.env = env def visit(self, node): if isinstance(node, ast.Expression): return self.visit(node.body) elif isinstance(node, ast.Num): # Py <3.8 fallback return node.n elif isinstance(node, ast.Constant): # numbers only if isinstance(node.value, (int, float)): return node.value raise ValueError("Only numeric constants are allowed") elif isinstance(node, ast.BinOp): left = self.visit(node.left) right = self.visit(node.right) if isinstance(node.op, ast.Add): return left + right if isinstance(node.op, ast.Sub): return left - right if isinstance(node.op, ast.Mult): return left * right if isinstance(node.op, ast.Div): return left / right if isinstance(node.op, ast.FloorDiv): return left // right if isinstance(node.op, ast.Mod): return left % right if isinstance(node.op, ast.Pow): return left ** right raise ValueError("Operator not allowed") elif isinstance(node, ast.UnaryOp): operand = self.visit(node.operand) if isinstance(node.op, ast.UAdd): return +operand if isinstance(node.op, ast.USub): return -operand raise ValueError("Unary operator not allowed") elif isinstance(node, ast.Call): if isinstance(node.func, ast.Name): fname = node.func.id if fname not in self.env or not callable(self.env[fname]): raise ValueError(f"Function '{fname}' not allowed") args = [self.visit(a) for a in node.args] return self.env[fname](*args) raise ValueError("Only simple function calls allowed") elif isinstance(node, ast.Name): name = node.id if name in self.env and not callable(self.env[name]): return self.env[name] raise ValueError(f"Name '{name}' not allowed") elif isinstance(node, ast.Expr): return self.visit(node.value) else: raise ValueError("Unsupported expression construct") @staticmethod def evaluate(expr: str, env: dict): tree = ast.parse(expr, mode="eval") return SafeEvaluator(env).visit(tree) 

------------------------------ Calculator UI ------------------------------

class UltimateCalculator: def init(self, root: tb.Window): self.root = root self.root.title("Ultimate Pro Calculator") self.root.geometry("520x680") self.root.resizable(False, False)

# State vars self.expression = "" self.ans = 0.0 self.memory = 0.0 self.deg_mode = tk.BooleanVar(value=True) # True=DEG, False=RAD # Top area: display + status top = tb.Frame(root, padding=10) top.pack(fill="x") self.display_var = tk.StringVar() self.display = tb.Entry(top, textvariable=self.display_var, font=("JetBrains Mono", 24), justify="right", state="readonly") self.display.pack(fill="x", ipady=14) status = tb.Frame(root, padding=(10, 0, 10, 10)) status.pack(fill="x") # DEG/RAD toggle self.mode_btn = tb.Checkbutton(status, text="DEG", bootstyle="round-toggle", variable=self.deg_mode, command=self._toggle_mode) self.mode_btn.pack(side="left") # Theme selector tb.Label(status, text="Theme:").pack(side="left", padx=(12, 4)) self.theme_box = ttk.Combobox(status, state="readonly", values=sorted(tb.Style().theme_names())) self.theme_box.set(root.style.name) self.theme_box.pack(side="left") self.theme_box.bind("<<ComboboxSelected>>", self._change_theme) # History panel (scrollable) hist_frame = tb.Labelframe(root, text="History", padding=8) hist_frame.pack(fill="x", padx=10, pady=(0, 8)) self.hist_list = tk.Listbox(hist_frame, height=4) self.hist_list.pack(side="left", fill="both", expand=True) tb.Button(hist_frame, text="Clear", bootstyle="secondary", command=self._clear_history).pack(side="right") self.history = [] # Memory row mem = tb.Frame(root, padding=(10, 0)) mem.pack(fill="x", pady=(0, 6)) for txt, cmd in [("MC", self._mc), ("MR", self._mr), ("M+", self._m_plus), ("M-", self._m_minus), ("MS", self._ms)]: tb.Button(mem, text=txt, width=4, bootstyle="secondary", command=cmd).pack(side="left", padx=4) tb.Label(mem, textvariable=tk.StringVar(value=" Ans available as 'Ans' "), bootstyle="light").pack(side="left") # Buttons grid grid = tb.Frame(root, padding=10) grid.pack(expand=True, fill="both") # Layout definition (rows of buttons) rows = [ ["C", "CE", "⌫", "(", ")", "%"], ["sin", "cos", "tan", "^", "√", "x²"], ["7", "8", "9", "÷", "mod", "!"], ["4", "5", "6", "×", "log", "ln"], ["1", "2", "3", "−", "exp", "xʸ"], ["±", "0", ".", "+", "1/x", "= "], ] for r, row in enumerate(rows): for c, label in enumerate(row): style = self._style_for(label) btn = tb.Button(grid, text=label, bootstyle=style, command=lambda ch=label: self.on_button(ch)) btn.grid(row=r, column=c, sticky="nsew", padx=4, pady=4, ipadx=6, ipady=10) for i in range(len(rows)): grid.rowconfigure(i, weight=1) for j in range(len(rows[0])): grid.columnconfigure(j, weight=1) # Keyboard bindings self.root.bind("<Key>", self._on_key) self.root.bind("<Return>", lambda e: self._equals()) self.root.bind("<KP_Enter>", lambda e: self._equals()) self.root.bind("<BackSpace>", lambda e: self._backspace()) self.root.bind("<Escape>", lambda e: self._clear_all()) self._render() # --------------------------- Button Handlers --------------------------- # def on_button(self, ch: str): if self.display_var.get() == "Error": self.expression = "" mapping = { "×": "*", "÷": "/", "−": "-", "^": "**", "x²": "**2", "xʸ": "**", "√": "sqrt(", "!": "!", "mod": "%", "1/x": "inv", "= ": "=", } if ch in ("C", "CE", "⌫", "= ", "±", "1/x"): if ch == "C": self._clear_all() elif ch == "CE": self._clear_entry() elif ch == "⌫": self._backspace() elif ch == "±": self._toggle_sign() elif ch == "1/x": self._apply_unary(lambda x: 1/x, "1/(") elif ch == "= ": self._equals() return # functional tokens that expand if ch in mapping: token = mapping[ch] if token == "inv": self._apply_unary(lambda x: 1/x, "1/(") return self.expression += token elif ch in ("sin", "cos", "tan", "log", "ln", "exp"): # insert with opening parenthesis; user will close or equals will auto-close func_map = { "sin": "sin(", "cos": "cos(", "tan": "tan(", "log": "log10(", "ln": "ln(", "exp": "exp(" } self.expression += func_map[ch] elif ch == "%": self.expression += "%" else: self.expression += ch.strip() self._render() # ------------------------------ Operations ---------------------------- # def _clear_all(self): self.expression = "" self._render() def _clear_entry(self): # Clear last token (number or function call chunk) if not self.expression: return # Remove until an operator or start self.expression = re.sub(r"([A-Za-z_]+?|\d+\.?\d*|)$", "", self.expression) self._render() def _backspace(self): if self.expression: self.expression = self.expression[:-1] self._render() def _toggle_sign(self): # Wrap current expression with negation if it's a plain number or closing paren if not self.expression: self.expression = "-" else: # add unary minus at end if last char is operator if self.expression[-1] in "+-*/%(**": self.expression += "-" else: self.expression = f"-({self.expression})" self._render() def _apply_unary(self, fn, hint_prefix: str): try: value = self._safe_eval(self.expression) if self.expression else 0.0 result = fn(value) self.expression = self._fmt(result) self._push_history(f"{hint_prefix}{self._fmt(value)}) = {self._fmt(result)}") except Exception as e: self._error(str(e)) self._render() def _equals(self): try: expr = self.expression # Auto-close open parentheses opens = expr.count("(") - expr.count(")") if opens > 0: expr += ")" * opens result = self._safe_eval(expr) self.ans = float(result) self._push_history(f"{expr} = {self._fmt(result)}") self.expression = self._fmt(result) except Exception as e: self._error(str(e)) self._render() # ------------------------------- Rendering ---------------------------- # def _render(self): self.display.configure(state="normal") self.display.delete(0, tk.END) self.display.insert(0, self.expression if self.expression else "0") self.display.configure(state="readonly") # Update mode label self.mode_btn.configure(text="DEG" if self.deg_mode.get() else "RAD") def _error(self, message: str): self.display.configure(state="normal") self.display.delete(0, tk.END) self.display.insert(0, "Error") self.display.configure(state="readonly") # Also show a subtle toast try: tb.toast.ToastNotification(title="Calculation Error", message=message, duration=2500, bootstyle="danger").show_toast() except Exception: # Fallback messagebox.showerror("Error", message) # ------------------------------- History ------------------------------ # def _push_history(self, item: str): self.history.append(item) self.hist_list.insert(tk.END, item) self.hist_list.see(tk.END) def _clear_history(self): self.history.clear() self.hist_list.delete(0, tk.END) # ------------------------------ Theme/Mode ----------------------------- # def _toggle_mode(self): # Just re-render text label; behavior handled in math wrappers self._render() def _change_theme(self, _): theme = self.theme_box.get() try: self.root.style.theme_use(theme) except Exception: pass def _style_for(self, label: str) -> str: if label.strip() == "=": return "success" if label in {"C", "CE", "⌫"}: return "danger" if label in {"+", "−", "×", "÷", "mod", "%", "^", "xʸ"}: return "warning" if label in {"sin", "cos", "tan", "log", "ln", "exp", "√", "x²", "!", "1/x"}: return "info" return "secondary" # ---------------------------- Expression Prep ------------------------- # def _preprocess(self, s: str) -> str: # Replace friendly symbols to Pythonic s = s.replace("×", "*").replace("÷", "/").replace("−", "-") s = s.replace("^", "**") # Percent: turn 50% -> (50/100) s = re.sub(r"(\d+(?:\.\d+)?)%", r"(\1/100)", s) # Factorial: n! -> fact(n) s = re.sub(r"(\d+(?:\.\d+)?|[^()]*)!", r"fact(\1)", s) # Sqrt shorthand s = s.replace("√", "sqrt") # Ans variable s = re.sub(r"\bAns\b", str(self.ans), s) return s def _math_env(self) -> dict: # Degree-aware trig wrappers def wrap_trig(f): def inner(x): if self.deg_mode.get(): return f(math.radians(x)) return f(x) return inner def wrap_inv_trig(f): def inner(x): val = f(x) return math.degrees(val) if self.deg_mode.get() else val return inner def fact(x): # Allow integer factorial; if float, try gamma(n+1) if abs(x - round(x)) < 1e-10 and x >= 0: return math.factorial(int(round(x))) if x > -1: return math.gamma(x + 1) raise ValueError("Factorial undefined for given value") env = { # constants 'pi': math.pi, 'e': math.e, 'tau': math.tau, # core math 'sqrt': math.sqrt, 'abs': abs, 'floor': math.floor, 'ceil': math.ceil, 'exp': math.exp, 'pow': pow, 'log10': math.log10, 'ln': math.log, # natural log 'log': math.log10, # map log to log10 'fact': fact, 'rand': random.random, } # trig + inverse + hyperbolic env.update({ 'sin': wrap_trig(math.sin), 'cos': wrap_trig(math.cos), 'tan': wrap_trig(math.tan), 'asin': wrap_inv_trig(math.asin), 'acos': wrap_inv_trig(math.acos), 'atan': wrap_inv_trig(math.atan), 'sinh': math.sinh, 'cosh': math.cosh, 'tanh': math.tanh, }) # dynamic variables env['Ans'] = self.ans env['M'] = self.memory return env def _safe_eval(self, expr: str) -> float: if not expr: return 0.0 expr = self._preprocess(expr) # Balance parentheses (safety) if expr.count('(') != expr.count(')'): raise ValueError("Unbalanced parentheses") # Only allowed chars (basic check; AST is the real gatekeeper) allowed = set("0123456789.+-*/%()_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ, ") if any(ch not in allowed for ch in expr): raise ValueError("Invalid characters in expression") env = self._math_env() val = SafeEvaluator.evaluate(expr, env) if isinstance(val, bool): raise ValueError("Boolean results not allowed") return float(val) @staticmethod def _fmt(x: float) -> str: # Pretty format try: if abs(x) < 1e-10: x = 0.0 s = ("{:.12g}").format(x) return s except Exception: return str(x) # ------------------------------ Memory API ---------------------------- # def _mc(self): self.memory = 0.0 def _mr(self): self.expression += self._fmt(self.memory) self._render() def _m_plus(self): try: self.memory += self._safe_eval(self.expression or "0") except Exception as e: self._error(str(e)) def _m_minus(self): try: self.memory -= self._safe_eval(self.expression or "0") except Exception as e: self._error(str(e)) def _ms(self): try: self.memory = self._safe_eval(self.expression or "0") except Exception as e: self._error(str(e)) # ------------------------------ Key Input ----------------------------- # def _on_key(self, event): k = event.keysym ch = event.char if k in ["Return", "KP_Enter"]: self._equals(); return if k == "BackSpace": self._backspace(); return if k == "Escape": self._clear_all(); return # Map keypad operators keypad_map = {"plus": "+", "minus": "-", "KP_Subtract": "-", "KP_Add": "+", "asterisk": "*", "KP_Multiply": "*", "slash": "/", "KP_Divide": "/"} if k in keypad_map: self.expression += keypad_map[k] self._render(); return # Accept typical characters if ch and ch in "0123456789.+-*/()%": self.expression += ch self._render(); return # Quick functions by typing quick = {"s": "sin(", "c": "cos(", "t": "tan(", "l": "log10(", "n": "ln(", "e": "exp("} if ch in quick: self.expression += quick[ch] self._render(); return 

--------------------------------- Main ----------------------------------

if name == "main": # Choose a nice default theme; user can switch from UI app = tb.Window(themename="superhero") UltimateCalculator(app) app.mainloop()
